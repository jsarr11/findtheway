<!DOCTYPE html>
<html lang="el">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FindTheWay-About Prim</title>
    <link rel="icon" href="/img/favicon.png" type="image/x-icon">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/css/styles.css">
    <script src="../node_modules/jquery/dist/jquery.min.js"></script>
    <script src="/js/language-switcher.js"></script>
</head>
<body>
<header>
    <div class="header-line">
        <a onclick="window.location.href='/user-page'"><img src="/img/logo_500x500.png" alt="logo" class="logo"></a>
        <button id="switch-lang">English</button>
    </div>
</header>
<main>

    <!-- Greek Content -->
    <div id="content-el">
        <div class="centered">
            <img src="./img/logo_500x500.png" alt="Logo" class="bigLogo">
        </div>
        <div class="info">
            <h1>Αλγόριθμος Prim - Σχετικά</h1>

            <p>Στο πλαίσιο της Θεωρίας γράφων, ένας γράφος είναι μια συλλογή από κορυφές (δηλαδή, σημεία) και
                ακμές (δηλαδή, γραμμές που συνδέουν τα σημεία). Οι κορυφές αντιστοιχούν σε οντότητες, ενώ μια ακμή
                μεταξύ δύο κορυφών υποδηλώνει ότι οι αντίστοιχες οντότητες σχετίζονται μεταξύ τους. Συνήθως, οι ακμές
                φέρουν βάρη που αντικατοπτρίζουν κάποιο κόστος που απαιτείται για τη δημιουργία τους, όπως φυσική ή
                εννοιολογική απόσταση, χρόνος, προϋπολογισμός κ.λπ.</p>

            <p>Τα δέντρα είναι ειδικές περιπτώσεις γράφων που είναι άκυκλα και συνδεδεμένα. Ένα δέντρο επικάλυψης
                ενός γράφου είναι ένα δέντρο που περιέχει όλες τις κορυφές του γράφου. Όταν ανατίθενται βάρη στις
                ακμές ενός γράφου, το ελάχιστο δέντρο επικάλυψης (MST) είναι το δέντρο επικάλυψης με το ελάχιστο
                συνολικό κόστος ακμών.</p>

            <p>Το πρόβλημα του MST στοχεύει στην εύρεση δέντρων επικάλυψης με ελάχιστο συνολικό κόστος για
                συνδεδεμένους γράφους και έχει πολλές πρακτικές εφαρμογές. Για παράδειγμα, φανταστείτε ότι οι
                κορυφές ενός γράφου αντιστοιχούν σε σπίτια, αεροδρόμια, κοντινά νησιά ή πύλες, και αναζητούμε τη
                βέλτιστη λύση για να τα συνδέσουμε με το ελάχιστο συνολικό κόστος, εξασφαλίζοντας ότι υπάρχει
                σύνδεση (όχι απαραίτητα άμεση) μεταξύ οποιωνδήποτε δύο σημείων.</p>

            <p>Για έναν συνδεδεμένο γράφο, μπορούμε να υπολογίσουμε αποτελεσματικά ένα ελάχιστο δέντρο επικάλυψης
                χρησιμοποιώντας δύο γνωστούς αλγορίθμους: τον αλγόριθμο του Prim και τον αλγόριθμο του Kruskal.
                Και οι δύο αλγόριθμοι επιστρέφουν παρόμοια αποτελέσματα, αλλά η προσέγγισή τους είναι ελαφρώς
                διαφορετική.</p>

            <h2>Κατανόηση του Αλγορίθμου Prim στην Πράξη</h2>

            <p>Σας παρουσιάζεται ένα νεοσύστατο χωριό όπου πρέπει να κατασκευαστούν πεζοδρόμια ώστε όλα τα σπίτια
                να συνδεθούν με τον χαμηλότερο δυνατό προϋπολογισμό. Μόνο οι πραγματικά ελάχιστου κόστους προτάσεις
                είναι επιλέξιμες για χρηματοδότηση.</p>

            <p>Το καθήκον σας είναι να αποφασίσετε ποια σπίτια πρέπει να συνδεθούν με πεζοδρόμια για να επιτευχθεί
                πλήρης σύνδεση με το ελάχιστο συνολικό κόστος. Μπορείτε να το κάνετε αυτό χρησιμοποιώντας μία από
                τις δύο διαθέσιμες μεθόδους: τη μία που προτάθηκε αρχικά από τον Vojtěch Jarník και αργότερα
                αναπτύχθηκε από τον Robert Prim, και μία άλλη που προτάθηκε από τον Joseph Kruskal.</p>

            <p>Σύμφωνα με τον Αλγόριθμο του Prim, σας δίνεται το σπίτι από όπου θα ξεκινήσουν οι εργασίες και το κόστος
                για όλα τα επιμέρους πεζοδρόμια μεταξύ οποιωνδήποτε δύο σπιτιών στο χωριό. Στη συνέχεια,
                δημιουργείτε την πρότασή σας βήμα προς βήμα, προσθέτοντας σπίτια που συνδέονται με ελάχιστου κόστους
                πεζοδρόμια στα σπίτια που έχετε ήδη συμπεριλάβει στη λύση σας, μέχρι να συνδεθούν όλα τα σπίτια.</p>

            <p>Ο αλγόριθμος του Prim ξεκινά από μια συγκεκριμένη κορυφή και κατασκευάζει το ελάχιστο δέντρο επικάλυψης
                σταδιακά, προσθέτοντας την φθηνότερη διαθέσιμη ακμή που επεκτείνει το δέντρο.</p>

            <p>Χρησιμοποιήστε τη βέλτιστη στρατηγική σας για να βοηθήσετε τους κατοίκους να εξασφαλίσουν χρηματοδότηση
                για τη βελτίωση του χωριού τους!</p>
        </div>

        <div class="button-container">
            <!-- Unified back route (e.g., /play-prim) -->
            <button id="back-button-el" onclick="window.location.href='/play-prim'">Πίσω</button>
        </div>
    </div>

    <!-- English Content (hidden by default) -->
    <div id="content-en" style="display:none;">
        <div class="centered">
            <img src="./img/logo_500x500.png" alt="Logo" class="bigLogo">
        </div>
        <div class="info">
            <h1>Prim Algorithm - About</h1>

            <p>In the context of graph theory, a graph is a collection of vertices (i.e., points) and edges
                (i.e., lines connecting points). Vertices correspond to entities, while an edge between two vertices
                implies that the corresponding entities are somehow related or associated. Usually, edges bear weights
                that reflect some sort of cost required for their establishment, such as physical or conceptual distance,
                time, budget, etc.</p>

            <p>Trees are special cases of graphs that are acyclic and connected. A spanning tree
                for a given graph is a tree containing all the vertices of this graph. When weights are assigned to
                the edges of a graph, a Minimum Spanning Tree (MST) is a spanning tree that has the minimum total
                edge-cost for that graph.</p>

            <p>The MST problem aims at finding spanning trees of minimum total cost for connected graphs
                and has many real-world applications. For example, imagine that the graph vertices correspond to
                houses, airports, nearby islands, or gates, and we seek minimum-cost solutions to connect all of them,
                ensuring that there exists a connection (not necessarily direct) between any two points at the
                lowest possible cost.</p>

            <p>Given a connected graph, we can efficiently compute a Minimum Spanning Tree using two well-known
                algorithms: Prim's algorithm and Kruskal's algorithm. Both algorithms yield similar results,
                but their approaches are slightly different.</p>

            <h2>Understanding Prim's Algorithm in Practice</h2>

            <p>You are presented with a newly created village where pavements must be constructed so that all
                houses are connected at the lowest possible budget. Only the truly minimum-cost proposals qualify
                for funding.</p>

            <p>Your task is to decide which houses should be connected with pavements to achieve full connectivity
                at minimum total cost. You can do this using one of two methods: one suggested initially by Vojtěch
                Jarník and later developed by Robert Prim, and another suggested by Joseph Kruskal.</p>

            <p>According to Prim's Algorithm, you are given the starting house and the cost for all individual
                pavements between any two houses in the village. You then build your proposal step by step, adding
                houses that are connected by minimum-cost pavements to houses you have already included in your
                solution, until all houses in the village are fully connected.</p>

            <p>Prim's algorithm starts from a particular vertex and constructs the Minimum Spanning Tree
                incrementally by adding the cheapest edge that expands the tree.</p>

            <p>Use your best strategy to help the residents obtain funding for improving their village!</p>
        </div>

        <div class="button-container">
            <!-- Unified back route (e.g., /play-prim) -->
            <button id="back-button-en" onclick="window.location.href='/play-prim'">Back</button>
        </div>
    </div>

</main>
</body>
</html>
